import * as fs from "fs/promises";
import * as path from "path";
import { createDirectus, readItems, rest } from "@directus/sdk";
// @ts-ignore: This file is generated on the first run.
import type { TranslationKey as CachedTranslationKey } from "@/.cache/Translation";

type Schema = {
  NavigationLink: NavigationLink[];
  Contact: Contact[];
  Translation: Translation[];
};

export type NavigationLink = {
  label_key: TranslationKey;
  url: string;
  category: "GENERAL" | "FOR_MEMBERS";
};

export type Contact = {
  label_key: TranslationKey;
  first_name: string;
  last_name: string;
  contact: string;
  id: number;
};

export type Translation = {
  key: string;
  fi: string;
  en: string;
  sv: string;
};

export type TranslationKey = CachedTranslationKey extends any
  ? string
  : CachedTranslationKey;

const CACHE_PATH = "./.cache";
const CACHE_TTL = 3600;

type CacheEntry = {
  data: any;
  expires: number;
};

const getCache = async (key: string) => {
  const cacheFilePath = path.resolve(CACHE_PATH, `${key}.json`);
  try {
    const entry = JSON.parse(
      await fs.readFile(cacheFilePath, "utf-8"),
    ) as CacheEntry;
    if (entry.expires < Date.now()) {
      return null;
    }

    return entry.data;
  } catch (error) {
    return null;
  }
};

const setCache = async (key: string, data: any) => {
  const cacheFilePath = path.resolve(CACHE_PATH, `${key}.json`);
  const entry: CacheEntry = {
    data,
    expires: Date.now() + CACHE_TTL * 1000,
  };

  await fs.mkdir(CACHE_PATH, { recursive: true });
  await fs.writeFile(cacheFilePath, JSON.stringify(entry));
};

const translationTypeFile = (translations: Translation[]) => `
// This file is generated by cmsClient.ts
export type TranslationKey =
  ${translations.map((t) => `"${t.key}"`).join("\n\t| ")};
`;

const createClient = () => {
  if (process.env.DIRECTUS_URL === undefined) {
    throw Error("Environment variable DIRECTUS_URL not defined");
  }
  const client = createDirectus<Schema>(process.env.DIRECTUS_URL).with(rest());

  return {
    getCollection: async <Collection extends keyof Schema>(
      collection: Collection,
    ): Promise<Schema[Collection]> => {
      const cachedResponse = await getCache(collection);
      if (cachedResponse) {
        return cachedResponse;
      }

      const response = await client.request(readItems(collection));
      await setCache(collection, response);
      if (collection === "Translation") {
        await fs.writeFile(
          path.resolve(CACHE_PATH, "Translation.ts"),
          translationTypeFile(response as Translation[]),
        );
      }
      return response as Schema[Collection];
    },
  };
};

export default createClient;
